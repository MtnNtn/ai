from search.model.Node import GameNode
import bisect

from games.model.Games import Game


class MinMax(object):

    def __init__(self, game):
        self.game = game

    def minmax_decision(self, state):
        ls = sorted([])
        for action in self.game.actions(state):
            res_state = self.game.result(state, action)
            bisect.insort_right(ls, GameNode(res_state, action=action, utility=self.min_value(res_state)))
        return ls.pop(ls.__len__()-1).action

    def max_value(self, state):
        if self.game.terminal_test(state):
            return self.game.utility(state)
        ls = sorted([])
        for action in self.game.actions(state):
            res_state = self.game.result(state, action)
            bisect.insort_right(ls, GameNode(res_state, action=action, utility=self.min_value(res_state)))
        return ls.pop(ls.__len__()-1).utility

    def min_value(self, state):
        if self.game.terminal_test(state):
            return self.game.utility(state)
        ls = sorted([])
        for action in self.game.actions(state):
            res_state = self.game.result(state, action)
            bisect.insort_right(ls, GameNode(res_state, action=action, utility=self.max_value(res_state)))
        return ls.pop(0).utility


class Test(object):

    class Foo(Game):

        def player(self, state):
            return None

        def actions(self, state):
            if state == "A":
                return ["a1", "a2", "a3"]
            elif state == "B":
                return ["b1", "b2", "b3"]
            elif state == "C":
                return ["c1", "c2", "c3"]
            elif state == "D":
                return ["d1", "d2", "d3"]
            return None

        def result(self, state, action):
            """ Returns a new state generated by applying the given action to te given state."""
            if state == "A":
                if action == "a1":
                    return "B"
                if action == "a2":
                    return "C"
                if action == "a3":
                    return "D"
            if state == "B":
                if action == "b1":
                    return "F1"
                if action == "b2":
                    return "F2"
                if action == "b3":
                    return "F3"
            if state == "C":
                if action == "c1":
                    return "F4"
                if action == "c2":
                    return "F5"
                if action == "c3":
                    return "F6"
            if state == "D":
                if action == "d1":
                    return "F7"
                if action == "d2":
                    return "F8"
                if action == "d3":
                    return "F9"

        @staticmethod
        def utility(state):
            if state == "F1":
                return 3
            elif state == "F2":
                return 12
            elif state == "F3":
                return 8
            elif state == "F4":
                return 2
            elif state == "F5":
                return 4
            elif state == "F6":
                return 6
            elif state == "F7":
                return 14
            elif state == "F8":
                return 5
            elif state == "F9":
                return 2

        def terminal_test(self, state):
            return "F" in state

        @staticmethod
        def same_state(state1, state2):
            return state1.__eq__(state2)

    x = Foo("A")
    print(MinMax(x).minmax_decision(x.initial_state))
