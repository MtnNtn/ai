class Game(object):
    """ An abstract Game is modeled by this elements:
        - Initial State : The initial State for the game
        - Player(s) : function that define which player has the move in a state
        - Actions(s): function that returns a set of possible actions that can be executed in the state s
        - Transition model: the function result(s,a) that return a new state generated by applying action a to a
        state s
        - terminal_test(s): function that checks if the game is over in the given state.
    """

    def __init__(self, initial_state):
        """ Initialize a new Problem with an initial state and a set of goal states."""
        self.initial_state = initial_state

    def player(self, state):
        """ Define which player has the move in a state."""
        raise NotImplementedError

    def actions(self, state):
        """ Returns the set of legal moves in a state."""
        raise NotImplementedError

    def result(self, state, action):
        """ Returns a new state generated by applying the given action to te given state."""
        raise NotImplementedError

    def terminal_test(self, state):
        """ Returns true if the given state is a terminal state, false otherwise. A terminal state is a state in which
        the game is over."""
        raise NotImplementedError

    @staticmethod
    def same_state(state1, state2):
        """ Return true if state1 is equal to state2, each problem defines states in its own way so is important that
         this function is implemented."""
        return state1.__eq__(state2)
